{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#!/usr/bin/env python\n",
    "\n",
    "import gym\n",
    "import rospy\n",
    "import time\n",
    "import numpy as np\n",
    "import tf\n",
    "import time\n",
    "from gym import utils, spaces\n",
    "from geometry_msgs.msg import Twist, Vector3Stamped, Pose\n",
    "from hector_uav_msgs.msg import Altimeter\n",
    "from sensor_msgs.msg import Imu\n",
    "from std_msgs.msg import Empty as EmptyTopicMsg\n",
    "from gym.utils import seeding\n",
    "from gym.envs.registration import register\n",
    "from gazebo_connection import GazeboConnection\n",
    "\n",
    "#register the training environment in the gym as an available one\n",
    "reg = register(\n",
    "    id='CodroneEnv-v0',\n",
    "    entry_point='codrone_env:CodroneEnv',\n",
    "    timestep_limit=1000,\n",
    "    )\n",
    "\n",
    "class CodroneEnv(gym.Env):\n",
    "\n",
    "    def __init__(self):\n",
    "        \n",
    "        # We assume that a ROS node has already been created\n",
    "        # before initialising the environment\n",
    "        \n",
    "        self.vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=5)\n",
    "        self.takeoff_pub = rospy.Publisher('/drone/takeoff', EmptyTopicMsg, queue_size=0)\n",
    "        \n",
    "        # gets training parameters from param server\n",
    "        self.speed_value = rospy.get_param(\"/speed_value\")\n",
    "        self.desired_pose = Pose()\n",
    "        self.desired_pose.position.z = rospy.get_param(\"/desired_pose/z\")\n",
    "        self.desired_pose.position.x = rospy.get_param(\"/desired_pose/x\")\n",
    "        self.desired_pose.position.y = rospy.get_param(\"/desired_pose/y\")\n",
    "        self.running_step = rospy.get_param(\"/running_step\")\n",
    "        self.max_incl = rospy.get_param(\"/max_incl\")\n",
    "        self.max_altitude = rospy.get_param(\"/max_altitude\")\n",
    "        \n",
    "        # stablishes connection with simulator\n",
    "        self.gazebo = GazeboConnection()\n",
    "        \n",
    "        self.action_space = spaces.Discrete(5) #Forward,Left,Right,Up,Down\n",
    "        self.reward_range = (-np.inf, np.inf)\n",
    "\n",
    "        self._seed()\n",
    "\n",
    "    # A function to initialize the random generator\n",
    "    def _seed(self, seed=None):\n",
    "        self.np_random, seed = seeding.np_random(seed)\n",
    "        return [seed]\n",
    "        \n",
    "    # Resets the state of the environment and returns an initial observation.\n",
    "    def _reset(self):\n",
    "        \n",
    "        # 1st: resets the simulation to initial values\n",
    "        self.gazebo.resetSim()\n",
    "\n",
    "        # 2nd: Unpauses simulation\n",
    "        self.gazebo.unpauseSim()\n",
    "\n",
    "        # 3rd: resets the robot to initial conditions\n",
    "        self.check_topic_publishers_connection()\n",
    "        self.init_desired_pose()\n",
    "        self.takeoff_sequence()\n",
    "\n",
    "        # 4th: takes an observation of the initial condition of the robot\n",
    "        data_pose, data_imu = self.take_observation()\n",
    "        observation = [data_pose.position.z]\n",
    "        \n",
    "        # 5th: pauses simulation\n",
    "        self.gazebo.pauseSim()\n",
    "\n",
    "        return observation\n",
    "\n",
    "    def _step(self, action):\n",
    "\n",
    "        # Given the action selected by the learning algorithm,\n",
    "        # we perform the corresponding movement of the robot\n",
    "        \n",
    "        # 1st, we decide which velocity command corresponds\n",
    "        vel_cmd = Twist()\n",
    "        if action == 0: #FORWARD\n",
    "            vel_cmd.linear.x = self.speed_value\n",
    "            vel_cmd.angular.z = 0.0\n",
    "        elif action == 1: #LEFT\n",
    "            vel_cmd.linear.x = 0.05\n",
    "            vel_cmd.angular.z = self.speed_value\n",
    "        elif action == 2: #RIGHT\n",
    "            vel_cmd.linear.x = 0.05\n",
    "            vel_cmd.angular.z = -self.speed_value\n",
    "        elif action == 3: #Up\n",
    "            vel_cmd.linear.z = self.speed_value\n",
    "            vel_cmd.angular.z = 0.0\n",
    "        elif action == 4: #Down\n",
    "            vel_cmd.linear.z = -self.speed_value\n",
    "            vel_cmd.angular.z = 0.0\n",
    "\n",
    "        # Then we send the command to the robot and let it go\n",
    "        # for running_step seconds\n",
    "        self.gazebo.unpauseSim()\n",
    "        self.vel_pub.publish(vel_cmd)\n",
    "        time.sleep(self.running_step)\n",
    "        data_pose, data_imu = self.take_observation()\n",
    "        self.gazebo.pauseSim()\n",
    "\n",
    "        # finally we get an evaluation based on what happened in the sim\n",
    "        reward,done = self.process_data(data_pose, data_imu)\n",
    "\n",
    "        # Promote going forwards instead of turning\n",
    "        if action == 0:\n",
    "            reward -= 50\n",
    "        elif action == 1 or action == 2:\n",
    "            reward -= 50\n",
    "        elif action == 3:\n",
    "            reward += 100\n",
    "        else:\n",
    "            reward -= 50\n",
    "\n",
    "        state = [data_pose.position.x]\n",
    "        return state, reward, done, {}\n",
    "\n",
    "\n",
    "    def take_observation (self):\n",
    "        data_pose = None\n",
    "        while data_pose is None:\n",
    "            try:\n",
    "                data_pose = rospy.wait_for_message('/drone/gt_pose', Pose, timeout=5)\n",
    "            except:\n",
    "                rospy.loginfo(\"Current drone pose not ready yet, retrying for getting robot pose\")\n",
    "\n",
    "        data_imu = None\n",
    "        while data_imu is None:\n",
    "            try:\n",
    "                data_imu = rospy.wait_for_message('/drone/imu', Imu, timeout=5)\n",
    "            except:\n",
    "                rospy.loginfo(\"Current drone imu not ready yet, retrying for getting robot imu\")\n",
    "        \n",
    "        return data_pose, data_imu\n",
    "\n",
    "    def calculate_dist_between_two_Points(self,p_init,p_end):\n",
    "        a = np.array((p_init.x ,p_init.y, p_init.z))\n",
    "        b = np.array((p_end.x ,p_end.y, p_end.z))\n",
    "        \n",
    "        dist = np.linalg.norm(a-b)\n",
    "        \n",
    "        return dist\n",
    "\n",
    "\n",
    "    def init_desired_pose(self):\n",
    "        \n",
    "        current_init_pose, imu = self.take_observation()\n",
    "        \n",
    "        self.best_dist = self.calculate_dist_between_two_Points(current_init_pose.position, self.desired_pose.position)\n",
    "    \n",
    "\n",
    "    def check_topic_publishers_connection(self):\n",
    "        \n",
    "        rate = rospy.Rate(10) # 10hz\n",
    "        while(self.takeoff_pub.get_num_connections() == 0):\n",
    "            rospy.loginfo(\"No susbribers to Takeoff yet so we wait and try again\")\n",
    "            rate.sleep();\n",
    "        rospy.loginfo(\"Takeoff Publisher Connected\")\n",
    "\n",
    "        while(self.vel_pub.get_num_connections() == 0):\n",
    "            rospy.loginfo(\"No susbribers to Cmd_vel yet so we wait and try again\")\n",
    "            rate.sleep();\n",
    "        rospy.loginfo(\"Cmd_vel Publisher Connected\")\n",
    "        \n",
    "\n",
    "    def reset_cmd_vel_commands(self):\n",
    "        # We send an empty null Twist\n",
    "        vel_cmd = Twist()\n",
    "        vel_cmd.linear.z = 0.0\n",
    "        vel_cmd.angular.z = 0.0\n",
    "        self.vel_pub.publish(vel_cmd)\n",
    "\n",
    "\n",
    "    def takeoff_sequence(self, seconds_taking_off=1):\n",
    "        # Before taking off be sure that cmd_vel value there is is null to avoid drifts\n",
    "        self.reset_cmd_vel_commands()\n",
    "        \n",
    "        takeoff_msg = EmptyTopicMsg()\n",
    "        rospy.loginfo( \"Taking-Off Start\")\n",
    "        self.takeoff_pub.publish(takeoff_msg)\n",
    "        time.sleep(seconds_taking_off)\n",
    "        rospy.loginfo( \"Taking-Off sequence completed\")\n",
    "        \n",
    "\n",
    "    def improved_distance_reward(self, current_pose):\n",
    "        current_dist = self.calculate_dist_between_two_Points(current_pose.position, self.desired_pose.position)\n",
    "        #rospy.loginfo(\"Calculated Distance = \"+str(current_dist))\n",
    "        \n",
    "        if current_dist < self.best_dist:\n",
    "            reward = 100\n",
    "            self.best_dist = current_dist\n",
    "        elif current_dist == self.best_dist:\n",
    "            reward = 0\n",
    "        else:\n",
    "            reward = -100\n",
    "            #print \"Made Distance bigger= \"+str(self.best_dist)\n",
    "        \n",
    "        return reward\n",
    "        \n",
    "    def process_data(self, data_position, data_imu):\n",
    "\n",
    "        done = False\n",
    "        \n",
    "        euler = tf.transformations.euler_from_quaternion([data_imu.orientation.x,data_imu.orientation.y,data_imu.orientation.z,data_imu.orientation.w])\n",
    "        roll = euler[0]\n",
    "        pitch = euler[1]\n",
    "        yaw = euler[2]\n",
    "\n",
    "        pitch_bad = not(-self.max_incl < pitch < self.max_incl)\n",
    "        roll_bad = not(-self.max_incl < roll < self.max_incl)\n",
    "        altitude_bad = data_position.position.z > self.max_altitude\n",
    "\n",
    "        if altitude_bad or pitch_bad or roll_bad:\n",
    "            rospy.loginfo (\"(Drone flight status is wrong) >>> (\"+str(altitude_bad)+\",\"+str(pitch_bad)+\",\"+str(roll_bad)+\")\")\n",
    "            done = True\n",
    "            reward = -200\n",
    "        else:\n",
    "            reward = self.improved_distance_reward(data_position)\n",
    "\n",
    "        return reward,done"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
